

# 第10章 CALL和RET指令

## 10.1 ret和retf

（1）ret 指令用栈中的数据，修改IP的内容，从而实现近转移。

​		（IP）= （（ss）*16+(sp)）

​		(sp) = (sp)+2

相当于进行：

​	pop IP

（2）retf指令用栈中的数据，修改cs和ip的内容，从而实现远转移。

（ip）=(ss)*16+(sp)

(sp)=(sp)+2

(CS)=((ss)*16+(sp))

(sp)=(sp)+2

相当于进行：

pop ip

pop cs

## 10.2 call指令

（1）执行call指令时进行两步操作

将当前的IP或者CS和IP压入栈中；

转移；



## 10.3 依据位移进行转移的CALL指令

（1）call标号（将当前的Ip压栈后，转到标号处执行指令）

（sp）=(sp)-2

((ss)*16+ (sp)) = (IP)

(IP)=(IP)+16位位移

相当于

push IP

jmp near ptr 标号

## 10.4 转移的目的地址在指令中的CALL指令

(1) call far ptr 标号---实现的段间转移

（sp）= (sp)-2

((ss)*16+ (sp))=(CS)

(SP)=(SP)-2

(SS)*16+SP = IP

CS=标号所在段的段地址

IP=标号在段中的偏移地址

相当于进行：

push CS

push IP

jmp far ptr 标号

## 10.5 转移地址在寄存器中的call指令

指令格式：

call	16位reg

功能

（sp）=(sp)-2

((ss)*16+(sp))=(ip)

(ip)=(16位reg)

相当于：

push	ip

jmp	16位reg

## 10.6 转移地址在内存中的CALL指令

转移地址在内存中的call指令有两种格式：

（1）call	word	内存单元地址

相当于进行：

push IP

jmp  word  ptr 内存单元地址

（2）call  dword  ptr 内存单元地址

相当于：

push	CS

push	IP

jmp	dword ptr 内存单元地址

## 10.7 call和ret的配合使用

利用call 和 ret 来实现子程序的机制：

框架如下：

标号：

​		指令

​		ret

具有子程序的源程序的框架如下：

```
assume cs:code
code segment
	main:	;
			;
			call sub1		;调用子程序sub1
			;
			;
			mov ax,4c00h
			int 21h
			
	sub1:	;				;子程序sub1开始
			;				
			call sub2		;调用子程序sub2
			;
			ret				;子程序返回
			
	sub2:	;				;子程序sub2开始
			;
			ret				;子程序返回
code ends
end main
```





## 10.8 mul指令

（1）两个相乘的数，要么都是8位，要么都是16位。

如果是8位，一个默认放在AL中，另一个放在8位或内存字节单元中；

如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中；

（2）8位乘法，结果默认放在ax中，如果是16位乘法，结果高位默认在dx中，低位在ax中放。

（3）格式：

​	mul	reg

​	mul	内存单元



## 10.9 模块化程序设计



## 10.10 参数和结果传递的问题

（1）子程序一般一般是要根据提供的参数处理一定的事务， 处理后，将结果（返回值）提供给调用者。

（2）本章讨论的问题就是应该如何存储子程序需要的参数和禅城的返回值。



## 10.11 批量数据的传递

将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。



## 10.12 寄存器冲突的问题

子程序是哟ing的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。

解决方案：用栈来保存寄存器中的内容

编写子程序的标准框架如下:



```
子程序开始：子程序使用的寄存器入栈
			子程序内容
			子程序中使用的寄存器出栈
			返回（ret、retf）
```





























