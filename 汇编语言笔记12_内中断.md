## 第12章 内中断

## 12.1 内中断的产生

（1）当cpu内部有下面的情况发生的时候，将产生相应的中断信息。

​		除法错误，比如div指令产生的除法溢出

​		单步执行

​		执行into指令

​		执行int指令

（2）中断类型码来标识中断信息的来源。

中断 类型码为一个字节型数据，可以表示256种中断信息的来源。

将产生中断信息的时间，即中断信息的来源，简称中断源。

如

除法错误		0

单步执行		1

执行into指令	4

执行int指令，该指令的格式为int n，指令种的n为字节型立即数，是提供给cpu的中断类型码。



## 12.2 中断处理程序

（1）处理中断信息的程序称为中断处理程序。

（2）中断类型码的作用就是用来定位中断处理程序。

### 12.3 中断向量表

（1）中断向量就是中断处理程序的入口地址。

（2）中断向量表，就是中断处理程序入口地址的列表。

中断向量表在内存种保存，其中存放着256个中断源所对应的中断处理程序的入口。

（3）CPU用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址。

（4）中断向量表在内存种存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存0000：0000到0000：03FF的1024个单元存放着中断向量表。

## 12.4 中断过程

（1）CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。

（2）下面是8086CPU在收到中断信息后，所引发的中断过程。

（从中断信息中）取得中断类型码；

标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）；

设置标志寄存器的第8位TF和第9位IF的值为0（这一步的目的后面介绍）；

CS的内容入栈；

IP的内容入栈；

从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS；

（3）更简洁的描述中断过程

取得中断类型码N

pushf

TF=0,IF=0

push CS

push IP

(IP)=(N*4), (CS)=(N*4+2)

最后一步完成后,CPU开始执行有程序员编写的中断处理程序。

## 12.5 中断处理程序和iret指令

（1）中断处理程序的编写方法和子程序的比较相似：

保存用到的寄存器

处理中断

恢复用到的寄存器

用iret指令返回

（2）iret指令的功能用汇编语法描述为：

pop IP

pop  CS

popf

## 12.6 除法错误中断的处理



## 12.7 编程处理0号中断

编程：当发生除法溢出时，在屏幕中间显示“over flow!”，返回dos.

程序       框架：

```
assume cs:code
code segment
start: do0安装程序
		设置中断向量表
		mov ax,4c00h
		int 21h
do0:	显示字符串“overflow!”
		mov ax,4c00h
		int 21h

code ends
end start
```





